"""
API endpoint tester
"""

import time
import requests
import jsonschema
from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging

from apitest.schema_parser import SchemaParser
from apitest.auth import AuthHandler
from apitest.core.test_generator import TestGenerator
from rich.console import Console

logger = logging.getLogger(__name__)


class TestStatus(Enum):
    """Test result status"""
    PASS = "pass"
    FAIL = "fail"
    WARNING = "warning"
    ERROR = "error"


@dataclass
class TestResult:
    """Result of a single endpoint test"""
    method: str
    path: str
    status_code: int
    expected_status: Optional[int] = None
    response_time_ms: float = 0.0
    status: TestStatus = TestStatus.PASS
    error_message: Optional[str] = None
    schema_mismatch: bool = False
    schema_errors: List[str] = field(default_factory=list)
    response_body: Optional[Dict[str, Any]] = None
    request_body: Optional[Dict[str, Any]] = None  # Request body that was sent
    expected_response: Optional[Dict[str, Any]] = None  # Expected response (status code and body)
    response_size_bytes: int = 0
    auth_attempts: int = 1  # Track how many auth methods were tried
    auth_succeeded: bool = True  # Whether any auth method succeeded
    data_source: Optional[str] = None  # 'learned', 'generated', or None (for non-POST/PUT/PATCH)
    is_ai_generated: bool = False  # Whether this test was generated by AI
    ai_metadata: Optional[Dict[str, Any]] = None  # AI generation metadata
    test_scenario: Optional[str] = None  # Test scenario description
    test_case_id: Optional[int] = None  # ID of AI test case in storage (if AI-generated)


@dataclass
class TestResults:
    """Collection of test results"""
    results: List[TestResult] = field(default_factory=list)
    total_time_seconds: float = 0.0
    
    def add_result(self, result: TestResult):
        """Add a test result"""
        self.results.append(result)
    
    def get_passed(self) -> List[TestResult]:
        """Get all passed tests"""
        return [r for r in self.results if r.status == TestStatus.PASS]
    
    def get_failed(self) -> List[TestResult]:
        """Get all failed tests"""
        return [r for r in self.results if r.status == TestStatus.FAIL]
    
    def get_warnings(self) -> List[TestResult]:
        """Get all warnings"""
        return [r for r in self.results if r.status == TestStatus.WARNING]
    
    def get_errors(self) -> List[TestResult]:
        """Get all errors"""
        return [r for r in self.results if r.status == TestStatus.ERROR]
    
    def has_failures(self) -> bool:
        """Check if there are any failures"""
        return len(self.get_failed()) > 0 or len(self.get_errors()) > 0
    
    def get_success_rate(self) -> float:
        """Calculate success rate as percentage"""
        if not self.results:
            return 0.0
        passed = len(self.get_passed())
        return (passed / len(self.results)) * 100


class APITester:
    """Test API endpoints from OpenAPI schema"""
    
    def __init__(self, schema: Dict[str, Any], auth_handlers: List[AuthHandler], 
                 timeout: int = 30, parallel: bool = False, verbose: bool = False,
                 path_params: Optional[Dict[str, str]] = None,
                 store_results: bool = False, schema_file: Optional[str] = None,
                 use_smart_data: bool = False, compare_baseline: bool = False,
                 test_generator: Optional[TestGenerator] = None, storage: Optional[Any] = None):
        self.schema = schema
        self.auth_handlers = auth_handlers if isinstance(auth_handlers, list) else [auth_handlers]
        if not self.auth_handlers:
            self.auth_handlers = [AuthHandler()]  # Default empty handler
        self.timeout = timeout
        self.parallel = parallel
        self.verbose = verbose
        self.parser = SchemaParser()
        self.path_params = path_params or {}
        self.default_path_param_warnings = []
        self.console = Console()
        self.store_results = store_results
        self.schema_file = schema_file
        self.use_smart_data = use_smart_data
        self.compare_baseline = compare_baseline
        self.test_generator = test_generator  # TestGenerator instance (with router)
        self.storage = storage  # Storage instance for AI test storage
        
        self.base_url = self.parser.get_base_url(schema)
        # Ensure we always have a valid base URL (must be full URL starting with http:// or https://)
        if not self.base_url or not self.base_url.strip() or not self.base_url.startswith(('http://', 'https://')):
            if self.verbose:
                self.console.print(f"[yellow]Warning: Base URL was invalid ({self.base_url or 'empty'}), using default: http://localhost:8000[/yellow]")
            self.base_url = 'http://localhost:8000'
            # Update schema to reflect this
            if 'servers' not in schema or not schema.get('servers'):
                schema['servers'] = [{'url': self.base_url}]
            elif schema.get('servers') and isinstance(schema['servers'][0], dict):
                schema['servers'][0]['url'] = self.base_url
    
    def run_tests(self, progress=None, task=None) -> TestResults:
        """
        Run tests for all endpoints in the schema
        
        Args:
            progress: Optional Rich Progress object for progress indication
            task: Optional Rich task ID for progress updates
        
        Returns:
            TestResults object with all test results
        """
        start_time = time.time()
        test_results = TestResults()
        paths = self.parser.get_paths(self.schema)
        
        # Collect endpoints for test generation
        endpoints = []
        for path, path_item in paths.items():
            if not isinstance(path_item, dict):
                continue
            
            methods = ['get', 'post', 'put', 'delete', 'patch', 'head', 'options']
            for method in methods:
                if method in path_item:
                    endpoints.append((method.upper(), path, path_item[method]))
        
        if not endpoints:
            return test_results
        
        # Generate test cases using TestGenerator router (if available)
        # Otherwise, use legacy approach
        if self.test_generator:
            # Use TestGenerator router to generate tests (supports schema/ai/hybrid modes)
            from apitest.core.test_generator import TestCase
            generated_test_cases = self.test_generator.generate_tests(self.schema, endpoints)
            
            # Execute tests
            if self.parallel:
                test_results = self._run_tests_parallel_from_test_cases(generated_test_cases)
            else:
                for test_case in generated_test_cases:
                    result = self._test_endpoint_from_test_case(test_case)
                    test_results.add_result(result)
                    if progress and task is not None:
                        progress.update(task, advance=1)
        else:
            # Legacy approach: generate tests on-the-fly
            if self.parallel:
                test_results = self._run_tests_parallel(endpoints)
            else:
                for method, path, operation in endpoints:
                    result = self._test_endpoint(method, path, operation)
                    test_results.add_result(result)
                    if progress and task is not None:
                        progress.update(task, advance=1)
        
        test_results.total_time_seconds = time.time() - start_time
        
        # Store results if enabled (with routing for AI vs schema)
        if self.store_results and self.schema_file:
            self._store_test_results(test_results)
        
        return test_results
    
    def _run_tests_parallel(self, test_cases: List[tuple]) -> TestResults:
        """Run tests in parallel"""
        test_results = TestResults()
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = {
                executor.submit(self._test_endpoint, method, path, operation): (method, path)
                for method, path, operation in test_cases
            }
            
            for future in as_completed(futures):
                try:
                    result = future.result()
                    test_results.add_result(result)
                except Exception as e:
                    method, path = futures[future]
                    error_result = TestResult(
                        method=method,
                        path=path,
                        status_code=0,
                        status=TestStatus.ERROR,
                        error_message=f"Test execution error: {str(e)}"
                    )
                    test_results.add_result(error_result)
        
        return test_results
    
    def _test_endpoint(self, method: str, path: str, operation: Dict[str, Any]) -> TestResult:
        """
        Test a single endpoint
        
        Args:
            method: HTTP method
            path: API path
            operation: OpenAPI operation object
            
        Returns:
            TestResult object
        """
        # Build URL
        url = self._build_url(path, operation)
        
        # Get expected status code
        expected_status = self._get_expected_status_code(operation)
        
        # Build request body if needed (same for all auth attempts)
        json_data = None
        data_source = None
        if method in ['POST', 'PUT', 'PATCH']:
            # Try to get request body from schema
            request_body = operation.get('requestBody', {})
            if request_body:
                # Generate test data (smart or regular)
                json_data = TestGenerator.generate_test_data(
                    request_body,
                    schema_file=self.schema_file if self.use_smart_data else None,
                    method=method if self.use_smart_data else None,
                    path=path if self.use_smart_data else None,
                    use_smart_generation=self.use_smart_data
                )
                
                # Track data source for reporting
                data_source = 'learned' if self.use_smart_data else 'generated'
        
        # Validate URL before making request
        if not url or not url.startswith(('http://', 'https://')):
            return TestResult(
                method=method,
                path=path,
                status_code=0,
                status=TestStatus.ERROR,
                error_message=f"Invalid URL: '{url}'. Base URL appears to be missing. Expected format: http://host:port/path or https://host:port/path"
            )
        
        # Try multiple auth handlers in sequence (like Django authentication_classes)
        last_result = None
        auth_attempts = 0
        
        for auth_handler in self.auth_handlers:
            auth_attempts += 1
            
            # Build request with current auth handler
            headers = auth_handler.get_headers()
            params = auth_handler.get_query_params()
            
            # Add content-type if needed
            if method in ['POST', 'PUT', 'PATCH']:
                headers.setdefault('Content-Type', 'application/json')
            
            # Execute request
            start_time = time.time()
            try:
                response = requests.request(
                    method=method,
                    url=url,
                    headers=headers,
                    params=params,
                    json=json_data,
                    data=None,
                    timeout=self.timeout,
                    allow_redirects=False
                )
                response_time_ms = (time.time() - start_time) * 1000
                response_size = len(response.content)
                
                # Parse response based on Content-Type
                response_body = None
                content_type = response.headers.get('Content-Type', '').lower()
                
                if response.content:
                    try:
                        if 'application/json' in content_type or 'application/vnd.api+json' in content_type:
                            response_body = response.json()
                        elif 'application/xml' in content_type or 'text/xml' in content_type:
                            # XML response - can't validate with JSON schema, but store as string
                            response_body = {'_xml_content': response.text}
                        elif 'text/' in content_type:
                            # Text response - store as string
                            response_body = {'_text_content': response.text}
                        else:
                            # Try JSON anyway (some APIs don't set Content-Type correctly)
                            try:
                                response_body = response.json()
                            except:
                                response_body = {'_raw_content': response.text[:500]}  # Truncate long responses
                    except Exception as e:
                        if self.verbose:
                            self.console.print(f"[dim]Warning: Could not parse response: {e}[/dim]")
                        response_body = None
                
                # Check if this is an auth failure (401/403) - if so, try next auth handler
                if response.status_code in [401, 403]:
                    # Auth failed, try next handler if available
                    if auth_attempts < len(self.auth_handlers):
                        if self.verbose:
                            self.console.print(f"[dim]Auth attempt {auth_attempts} failed with {response.status_code} for {method} {path}, trying next auth...[/dim]")
                        last_result = None
                        continue  # Try next auth handler
                    else:
                        # Last auth handler also failed
                        last_result = self._create_result_from_response(
                            method, path, response, response_body, response_time_ms, 
                            response_size, expected_status, operation, auth_attempts, False, data_source,
                            request_body=json_data
                        )
                        break
                else:
                    # This auth worked (not 401/403), use this result
                    last_result = self._create_result_from_response(
                        method, path, response, response_body, response_time_ms,
                        response_size, expected_status, operation, auth_attempts, True, data_source,
                        request_body=json_data
                    )
                    break  # Success, no need to try more auth handlers
                    
            except requests.exceptions.Timeout:
                # Timeout - don't retry with other auths, return error
                return TestResult(
                    method=method,
                    path=path,
                    status_code=0,
                    status=TestStatus.ERROR,
                    error_message=f"Request timeout after {self.timeout}s (try increasing with --timeout)",
                    auth_attempts=auth_attempts,
                    auth_succeeded=False
                )
            except requests.exceptions.InvalidURL as e:
                error_msg = str(e)
                # Provide more helpful error message
                if "No scheme supplied" in error_msg or "Invalid URL" in error_msg:
                    error_msg = f"Invalid URL format: '{url}'. Base URL is missing or invalid. Please check the schema's 'servers' field or use --base-url option."
                return TestResult(
                    method=method,
                    path=path,
                    status_code=0,
                    status=TestStatus.ERROR,
                    error_message=f"URL error: {error_msg}",
                    auth_attempts=auth_attempts,
                    auth_succeeded=False
                )
            except requests.exceptions.ConnectionError as e:
                # Connection error - don't retry with other auths, return error
                error_msg = str(e)
                if "Failed to resolve" in error_msg or "Name or service not known" in error_msg:
                    error_msg = f"Cannot connect to {url}. Check if the server is running and the base URL is correct."
                elif "Connection refused" in error_msg:
                    error_msg = f"Connection refused for {url}. Is the server running on this address?"
                return TestResult(
                    method=method,
                    path=path,
                    status_code=0,
                    status=TestStatus.ERROR,
                    error_message=f"Connection error: {error_msg}",
                    auth_attempts=auth_attempts,
                    auth_succeeded=False
                )
            except requests.exceptions.RequestException as e:
                # Request error - don't retry with other auths, return error
                return TestResult(
                    method=method,
                    path=path,
                    status_code=0,
                    status=TestStatus.ERROR,
                    error_message=f"Request error: {str(e)}",
                    auth_attempts=auth_attempts,
                    auth_succeeded=False
                )
            except Exception as e:
                # Catch all other errors - don't retry with other auths
                error_msg = str(e)
                if self.verbose:
                    import traceback
                    self.console.print(f"[red]Error details for {method} {path}:[/red]")
                    self.console.print(f"[dim]{traceback.format_exc()}[/dim]")
                return TestResult(
                    method=method,
                    path=path,
                    status_code=0,
                    status=TestStatus.ERROR,
                    error_message=f"Unexpected error: {error_msg}",
                    auth_attempts=auth_attempts,
                    auth_succeeded=False
                )
        
        # Return last result (or None if all auths failed - shouldn't happen, but handle it)
        if last_result is None:
            # All auth handlers were tried and all returned 401/403
            return TestResult(
                method=method,
                path=path,
                status_code=401,
                expected_status=expected_status,
                status=TestStatus.FAIL,
                error_message=f"All {auth_attempts} authentication method(s) failed with 401/403",
                auth_attempts=auth_attempts,
                auth_succeeded=False
            )
        
        return last_result
    
    def _create_result_from_response(self, method: str, path: str, response: requests.Response,
                                     response_body: Optional[Dict[str, Any]], response_time_ms: float,
                                     response_size: int, expected_status: Optional[int],
                                     operation: Dict[str, Any], auth_attempts: int, auth_succeeded: bool,
                                     data_source: Optional[str] = None,
                                     request_body: Optional[Dict[str, Any]] = None,
                                     expected_response: Optional[Dict[str, Any]] = None) -> TestResult:
        """Helper method to create TestResult from a response"""
        # Validate response
        status = TestStatus.PASS
        error_message = None
        schema_mismatch = False
        schema_errors = []
        
        # Build expected_response if not provided
        if expected_response is None and operation.get('responses'):
            # Extract expected response from operation
            responses = operation.get('responses', {})
            if expected_status:
                status_key = str(expected_status)
                if status_key in responses:
                    expected_response = responses[status_key]
                    if 'status_code' not in expected_response:
                        expected_response = {'status_code': expected_status, **expected_response}
            elif '200' in responses:
                expected_response = {'status_code': 200, **responses['200']}
        
        # Check status code
        if expected_status and response.status_code != expected_status:
            status = TestStatus.FAIL
            error_message = f"Expected {expected_status}, got {response.status_code}"
        
        # Check response schema (only for JSON responses)
        if response.status_code < 400 and operation.get('responses'):
            content_type = response.headers.get('Content-Type', '').lower()
            if 'application/json' in content_type or 'application/vnd.api+json' in content_type:
                schema_errors = self._validate_response_schema(
                    response_body, response.status_code, operation.get('responses', {})
                )
                if schema_errors:
                    schema_mismatch = True
                    status = TestStatus.WARNING if status == TestStatus.PASS else status
            elif content_type and 'json' not in content_type:
                # Non-JSON response - can't validate schema, but that's OK
                if self.verbose:
                    self.console.print(f"[dim]Skipping schema validation for Content-Type: {content_type}[/dim]")
        
        return TestResult(
            method=method,
            path=path,
            status_code=response.status_code,
            expected_status=expected_status,
            response_time_ms=response_time_ms,
            status=status,
            error_message=error_message,
            schema_mismatch=schema_mismatch,
            schema_errors=schema_errors,
            response_body=response_body,
            request_body=request_body,
            expected_response=expected_response,
            response_size_bytes=response_size,
            auth_attempts=auth_attempts,
            auth_succeeded=auth_succeeded,
            data_source=data_source
        )
    
    def _build_url(self, path: str, operation: Optional[Dict[str, Any]] = None) -> str:
        """
        Build full URL from base URL and path
        
        Args:
            path: API path with potential parameters
            operation: OpenAPI operation object (for parameter schema)
        """
        # Ensure base URL is set and valid (safety check - must be full URL starting with http:// or https://)
        if not self.base_url or not self.base_url.strip() or not self.base_url.startswith(('http://', 'https://')):
            if self.verbose:
                self.console.print(f"[yellow]Warning: Base URL was invalid ({self.base_url or 'empty'}), using default: http://localhost:8000[/yellow]")
            self.base_url = 'http://localhost:8000'
            # Update schema to reflect this
            if 'servers' not in self.schema or not self.schema.get('servers'):
                self.schema['servers'] = [{'url': self.base_url}]
            elif self.schema.get('servers') and isinstance(self.schema['servers'][0], dict):
                self.schema['servers'][0]['url'] = self.base_url
        
        base = self.base_url.rstrip('/')
        path = path.lstrip('/')
        
        # Replace path parameters with test values based on schema
        import re
        
        # Find all path parameters
        param_matches = re.finditer(r'\{([^}]+)\}', path)
        
        for match in param_matches:
            param_name = match.group(1)
            
            # Check if custom value provided
            if param_name in self.path_params:
                test_value = self.path_params[param_name]
            else:
                # Generate default value and warn
                test_value = self._generate_path_param_value(param_name, operation)
                warning_msg = f"⚠ Using default path parameter: {param_name}={test_value}"
                if warning_msg not in self.default_path_param_warnings:
                    self.default_path_param_warnings.append(warning_msg)
                    if self.verbose:
                        self.console.print(f"[yellow]{warning_msg}[/yellow] (for path: {path})")
            
            path = path.replace(f'{{{param_name}}}', str(test_value))
        
        return f"{base}/{path}"
    
    def _generate_path_param_value(self, param_name: str, operation: Optional[Dict[str, Any]]) -> Any:
        """
        Generate test value for path parameter based on schema
        
        Args:
            param_name: Parameter name
            operation: OpenAPI operation object
            
        Returns:
            Test value for the parameter
        """
        if operation:
            parameters = operation.get('parameters', [])
            for param in parameters:
                if param.get('in') == 'path' and param.get('name') == param_name:
                    schema = param.get('schema', {})
                    param_type = schema.get('type', 'string')
                    param_format = schema.get('format', '')
                    
                    # Generate based on type and format
                    if param_type == 'integer':
                        return 1
                    elif param_type == 'number':
                        return 1.0
                    elif param_format == 'uuid':
                        return '123e4567-e89b-12d3-a456-426614174000'
                    elif param_format == 'date':
                        return '2024-01-01'
                    elif param_format == 'date-time':
                        return '2024-01-01T00:00:00Z'
                    else:
                        return 'test'
        
        # Default fallback
        return 1
    
    def _get_expected_status_code(self, operation: Dict[str, Any]) -> Optional[int]:
        """Get expected status code from operation"""
        responses = operation.get('responses', {})
        
        # Look for 2xx status codes first
        for status_code in ['200', '201', '202', '204']:
            if status_code in responses:
                return int(status_code)
        
        # Return first available status code
        if responses:
            first_status = list(responses.keys())[0]
            if first_status.isdigit():
                return int(first_status)
        
        return None
    
    
    def _validate_response_schema(self, response_body: Any, status_code: int, 
                                  responses: Dict[str, Any]) -> List[str]:
        """Validate response schema using jsonschema"""
        errors = []
        
        # Find response definition for this status code
        status_key = str(status_code)
        if status_key not in responses:
            # Check for default or wildcard
            status_key = 'default' if 'default' in responses else None
        
        if not status_key:
            return errors
        
        response_def = responses[status_key]
        content = response_def.get('content', {})
        
        # Try to find JSON schema
        json_content = content.get('application/json') or content.get('application/vnd.api+json')
        
        if not json_content:
            # No JSON schema defined, skip validation
            return errors
        
        schema = json_content.get('schema')
        if not schema:
            return errors
        
        # Resolve $ref references if present
        resolved_schema = self._resolve_schema_refs(schema)
        
        # Validate response against schema
        try:
            jsonschema.validate(instance=response_body, schema=resolved_schema)
        except jsonschema.ValidationError as e:
            errors.append(f"Schema validation failed: {e.message}")
            if e.path:
                errors.append(f"  Path: {'/'.join(str(p) for p in e.path)}")
        except jsonschema.SchemaError as e:
            errors.append(f"Invalid schema definition: {e.message}")
        except Exception as e:
            errors.append(f"Validation error: {str(e)}")
        
        return errors
    
    def _resolve_schema_refs(self, schema: Dict[str, Any]) -> Dict[str, Any]:
        """
        Resolve $ref references in schema
        Basic implementation - resolves components/schemas references
        """
        if not isinstance(schema, dict):
            return schema
        
        # Check for $ref
        if '$ref' in schema:
            ref_path = schema['$ref']
            if ref_path.startswith('#/components/schemas/'):
                schema_name = ref_path.replace('#/components/schemas/', '')
                components = self.schema.get('components', {})
                schemas = components.get('schemas', {})
                if schema_name in schemas:
                    return self._resolve_schema_refs(schemas[schema_name])
        
        # Recursively resolve nested references
        resolved = {}
        for key, value in schema.items():
            if isinstance(value, dict):
                resolved[key] = self._resolve_schema_refs(value)
            elif isinstance(value, list):
                resolved[key] = [self._resolve_schema_refs(item) if isinstance(item, dict) else item for item in value]
            else:
                resolved[key] = value
        
        return resolved
    
    def _test_endpoint_from_test_case(self, test_case) -> TestResult:
        """
        Test an endpoint from a TestCase object (supports AI-generated tests)
        
        Args:
            test_case: TestCase object with method, path, request_body, etc.
            
        Returns:
            TestResult object
        """
        from apitest.core.test_generator import TestCase as TestCaseType
        
        # Get operation from schema
        paths = self.parser.get_paths(self.schema)
        path_item = paths.get(test_case.path, {})
        operation = path_item.get(test_case.method.lower(), {})
        
        # Build URL
        url = self._build_url(test_case.path, operation)
        
        # Get expected status code from test case or operation
        expected_status = None
        if test_case.expected_response:
            expected_status = test_case.expected_response.get('status_code')
        if not expected_status:
            expected_status = self._get_expected_status_code(operation)
        
        # Use request body from test case
        json_data = test_case.request_body
        
        # Validate URL
        if not url or not url.startswith(('http://', 'https://')):
            return TestResult(
                method=test_case.method,
                path=test_case.path,
                status_code=0,
                status=TestStatus.ERROR,
                error_message=f"Invalid URL: '{url}'",
                is_ai_generated=test_case.is_ai_generated,
                ai_metadata=test_case.ai_metadata,
                test_scenario=test_case.test_scenario
            )
        
        # Execute request with auth handlers
        last_result = None
        auth_attempts = 0
        
        for auth_handler in self.auth_handlers:
            auth_attempts += 1
            headers = auth_handler.get_headers()
            params = auth_handler.get_query_params()
            
            if test_case.method in ['POST', 'PUT', 'PATCH']:
                headers.setdefault('Content-Type', 'application/json')
            
            start_time = time.time()
            try:
                response = requests.request(
                    method=test_case.method,
                    url=url,
                    headers=headers,
                    params=params,
                    json=json_data,
                    timeout=self.timeout,
                    allow_redirects=False
                )
                response_time_ms = (time.time() - start_time) * 1000
                response_size = len(response.content)
                
                # Parse response
                response_body = None
                content_type = response.headers.get('Content-Type', '').lower()
                
                if response.content:
                    try:
                        if 'application/json' in content_type:
                            response_body = response.json()
                        else:
                            try:
                                response_body = response.json()
                            except:
                                response_body = {'_raw_content': response.text[:500]}
                    except Exception:
                        response_body = {'_raw_content': response.text[:500]}
                
                # Validate response
                status = TestStatus.PASS
                schema_mismatch = False
                schema_errors = []
                
                if expected_status and response.status_code != expected_status:
                    status = TestStatus.FAIL
                
                # Validate response schema if available
                if test_case.expected_response and 'body' in test_case.expected_response:
                    # Basic validation - could be enhanced
                    pass
                
                result = TestResult(
                    method=test_case.method,
                    path=test_case.path,
                    status_code=response.status_code,
                    expected_status=expected_status,
                    response_time_ms=response_time_ms,
                    status=status,
                    schema_mismatch=schema_mismatch,
                    schema_errors=schema_errors,
                    response_body=response_body,
                    request_body=test_case.request_body,
                    expected_response=test_case.expected_response,
                    response_size_bytes=response_size,
                    auth_attempts=auth_attempts,
                    auth_succeeded=True,
                    is_ai_generated=test_case.is_ai_generated,
                    ai_metadata=test_case.ai_metadata,
                    test_scenario=test_case.test_scenario
                )
                
                last_result = result
                break  # Success, exit auth loop
                
            except requests.exceptions.RequestException as e:
                last_result = TestResult(
                    method=test_case.method,
                    path=test_case.path,
                    status_code=0,
                    status=TestStatus.ERROR,
                    error_message=str(e),
                    auth_attempts=auth_attempts,
                    auth_succeeded=False,
                    is_ai_generated=test_case.is_ai_generated,
                    ai_metadata=test_case.ai_metadata,
                    test_scenario=test_case.test_scenario
                )
        
        return last_result or TestResult(
            method=test_case.method,
            path=test_case.path,
            status_code=0,
            status=TestStatus.ERROR,
            error_message="All authentication methods failed",
            auth_attempts=auth_attempts,
            auth_succeeded=False,
            is_ai_generated=test_case.is_ai_generated,
            ai_metadata=test_case.ai_metadata,
            test_scenario=test_case.test_scenario
        )
    
    def _run_tests_parallel_from_test_cases(self, test_cases: List) -> TestResults:
        """Run tests in parallel from TestCase objects"""
        test_results = TestResults()
        
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = {
                executor.submit(self._test_endpoint_from_test_case, test_case): test_case
                for test_case in test_cases
            }
            
            for future in as_completed(futures):
                try:
                    result = future.result()
                    test_results.add_result(result)
                except Exception as e:
                    test_case = futures[future]
                    error_result = TestResult(
                        method=test_case.method,
                        path=test_case.path,
                        status_code=0,
                        status=TestStatus.ERROR,
                        error_message=f"Test execution error: {str(e)}",
                        is_ai_generated=test_case.is_ai_generated,
                        ai_metadata=test_case.ai_metadata,
                        test_scenario=test_case.test_scenario
                    )
                    test_results.add_result(error_result)
        
        return test_results
    
    def _store_test_results(self, test_results: TestResults):
        """
        Store test results with routing for AI vs schema tests
        
        Args:
            test_results: TestResults object with all test results
        """
        if not self.schema_file:
            return
        
        try:
            # Separate AI and schema test results
            ai_results = [r for r in test_results.results if r.is_ai_generated]
            schema_results = [r for r in test_results.results if not r.is_ai_generated]
            
            # Store schema results using traditional method
            if schema_results:
                from apitest.storage import TestHistory
                with TestHistory() as history:
                    # Create TestResults with only schema results
                    schema_test_results = TestResults()
                    schema_test_results.results = schema_results
                    schema_test_results.total_time_seconds = test_results.total_time_seconds
                    history.save_test_results(self.schema_file, schema_test_results, store_payloads=True)
            
            # Store AI test results
            if ai_results and self.storage:
                for result in ai_results:
                    # Save AI test case if not already saved
                    if result.test_case_id is None and result.ai_metadata:
                        # Create test case JSON
                        test_case_json = {
                            'test_scenario': result.test_scenario,
                            'request_body': None,  # Would need to track this
                            'expected_response': {
                                'status_code': result.expected_status or 200
                            }
                        }
                        
                        # Save to AI tests storage
                        test_case_id = self.storage.ai_tests.save_test_case(
                            schema_file=self.schema_file,
                            method=result.method,
                            path=result.path,
                            test_case_json=test_case_json,
                            validation_status='pending'
                        )
                        result.test_case_id = test_case_id
            
            if self.verbose:
                self.console.print(f"[dim]✓ Test results saved to local database[/dim]")
                if ai_results:
                    self.console.print(f"[dim]  ({len(ai_results)} AI-generated, {len(schema_results)} schema-based)[/dim]")
                    
        except Exception as e:
            logger.warning(f"Failed to store test results: {e}")
            if self.verbose:
                self.console.print(f"[yellow]Warning: Could not save test results: {e}[/yellow]")

